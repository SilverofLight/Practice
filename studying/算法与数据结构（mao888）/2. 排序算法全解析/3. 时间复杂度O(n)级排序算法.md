
# 计数排序

前文说到，1959 年 7 月，希尔排序通过交换非相邻元素，打破了O(n^2) 的魔咒，使得排序算法的时间复杂度降到了 O(n log⁡n)级，此后的快速排序、堆排序都是基于这样的思想，所以他们的时间复杂度都是 O(n log⁡n)。

事实上，O(n) 级的排序算法存在已久，但他们只能用于特定的场景。

计数排序就是一种时间复杂度为 O(n) 的排序算法，该算法于 1954 年由 `Harold H. Seward` 提出。在对一定范围内的整数排序时，它的复杂度为 Ο(n+k)（其中 `k` 是整数的范围大小）。

## 伪计数排序

举个例子，我们需要对一列数组排序，这个数组中每个元素都是 [1, 9] 区间内的整数。那么我们可以构建一个长度为 9 的数组用于计数，计数数组的下标分别对应区间内的 9 个整数。然后遍历待排序的数组，将区间内每个整数出现的次数统计到计数数组中对应下标的位置。最后遍历计数数组，将每个元素输出，输出的次数就是对应位置记录的次数。

算法实现如下（以 [1, 9] 为例 ）：

~~~go
func countingSort9(arr []int) {
	// 建立长度为 9 的数组，下标 0~8 对应 1~9
	counting := make([]int, 9)
	// 遍历 arr 中的元素
	for _, v := range arr {
		counting[v-1]++
	}
	index := 0
	// 遍历数组，将每个元素输出
	for i := 0; i < 9; i++ {
		for counting[i] != 0{
			arr[index++] = i + 1
			counting--
		}
	}
}
~~~

算法非常简单，但这里的排序算法 **并不是** 真正的计数排序。因为现在的实现有一个非常大的弊端：排序完成后，`arr` 中记录的元素已经不再是最开始的那个元素了，他们只是值相等，但却不是同一个对象。

## 伪计数排序 2.0

对于这个问题，我们很容易想到一种解决方案：在统计元素出现的次数时，同时把真实的元素保存到列表中，输出时，从列表中取真实的元素。算法实现如下：

~~~go
package main

import (
	"container/list"
)

func countingSort9(arr []int) {
	// 建立长度为 9 的数组，下标 0~8 对应数字 1~9
	counting := make([]int, 9)
	// 记录每个下标中包含的真实元素，使用队列可以保证排序的稳定性
	records := make(map[int]*list.List)
	// 遍历 arr 中的每个元素
	for _, element := range arr {
		// 将每个整数出现的次数统计到计数数组中对应下标的位置
		counting[element-1]++
		if _, ok := records[element-1]; !ok {
			records[element-1] = list.New()
		}
		records[element-1].PushBack(element)
	}
	index := 0
	// 遍历计数数组，将每个元素输出
	for i := 0; i < 9; i++ {
		// 输出的次数就是对应位置记录的次数
		for counting[i] != 0 {
			// 输出记录的真实元素
			element := records[i].Front().Value.(int)
			arr[index] = element
			index++
			records[i].Remove(records[i].Front())
			counting[i]--
		}
	}
}
~~~

在这份代码中，我们通过队列来保存真实的元素，计数完成后，将队列中真实的元素赋到 `arr` 列表中，这就解决了信息丢失的问题，并且使用队列还可以保证排序算法的稳定性。

但是，**这也不是** 真正的计数排序，计数排序中使用了一种更巧妙的方法解决这个问题。

## 真正的计数排序

举个例子，班上有 10 名同学：他们的考试成绩分别是：7,8,9,7,6,7,6,8,6,6，他们需要按照成绩从低到高坐到 0～9共 10 个位置上。  
用计数排序完成这一过程需要以下几步：

- 第一步仍然是计数，统计出：4 名同学考了 6 分，3 名同学考了 7 分，2名同学考了 8 分，1 名同学考了 9 分；
- 然后从头遍历数组：第一名同学考了 7 分，共有 4 个人比他分数低，所以第一名同学坐在 4 号位置（也就是第 5 个位置）；
- 第二名同学考了 8 分，共有 7 个人（4 + 3）比他分数低，所以第二名同学坐在 7 号位置；
- 第三名同学考了 9 分，共有 9 个人（4 + 3 + 2）比他分数低，所以第三名同学坐在 9 号位置；
- 第四名同学考了 7 分，共有 4 个人比他分数低，并且之前已经有一名考了 7 分的同学坐在了 4 号位置，所以第四名同学坐在 5号位置。
- ...依次完成整个排序

区别就在于计数排序并不是把计数数组的下标直接作为结果输出，而是通过计数的结果，计算出每个元素在排序完成后的位置，然后将元素赋值到对应位置。

代码如下：

~~~go
func countingSort9(arr []int) {
	counting := make([]int, 9)
	for _, element := range arr {
		counting[element]++
	}
	// 记录前面比自己小的数字的总数
	preCounts := 0
	for i := 0; i < len(counting); i++ {
		temp := counting[i]
		// 将 counting 计算成当前数字在结果中的起始下标位置。位置 = 前面比自己小的数字的总数
		counting[i] = preCounts
		// 当前数字比下一个数字小，累计到 preCount 中
		preCounts += temp
	}
	result := make([]int, len(arr))
	for _, element := range arr {
		// counting[element - 1] 表示此元素在结果数组中的下标
		index := counting[element - 1]
		result[index] = element
		// 更新 counting[element - 1]，指向此元素的下一个下标
		counting[element - 1]++
	}
	// 将结果返回给arr
	for i := 0; i < len(arr); i++ {
		arr[i] = result[i]
	}
}
~~~

首先我们将每位元素出现的次数记录到 `counting` 数组中。

然后将 `counting[i]` 更新为数字 `i` 在最终排序结果中的起始下标位置。这个位置等于前面比自己小的数字的总数。  
例如本例中，考 7 分的同学前面有 4 个比自己分数低的同学，所以 7 对应的下标为 4。  
这一步除了使用 `temp` 变量这种写法以外，还可以通过多做一次减法省去 `temp` 变量：

~~~java
// 记录前面比自己小的数字的总数
int preCounts = 0;
for (int i = 0; i < counting.length; i++) {
    // 当前的数字比下一个数字小，累计到 preCounts 中
    preCounts += counting[i];
    // 将 counting 计算成当前数字在结果中的起始下标位置。位置 = 前面比自己小的数字的总数。
    counting[i] = preCounts - counting[i];
}
~~~

接下来从头访问 `arr` 数组，根据 `counting` 中计算出的下标位置，将 `arr` 的每个元素直接放到最终位置上，然后更新 `counting` 中的下标位置。这一步中的 `index` 变量也是可以省略的。

最后将 `result` 数组赋值回 `arr`，完成排序。

这就是计数排序的思想，我们还剩下最后一步，那就是根据 `arr` 中的数字范围计算出计数数组的长度。使得计数排序不仅仅适用于 [1,9]，代码如下：

~~~java
public static void countingSort(int[] arr) {
    // 判空及防止数组越界
    if (arr == null || arr.length <= 1) return;
    // 找到最大值，最小值
    int max = arr[0];
    int min = arr[0];
    for (int i = 1; i < arr.length; i++) {
        if (arr[i] > max) max = arr[i];
        else if (arr[i] < min) min = arr[i];
    }
    // 确定计数范围
    int range = max - min + 1;
    // 建立长度为 range 的数组，下标 0~range-1 对应数字 min~max
    int[] counting = new int[range];
    // 遍历 arr 中的每个元素
    for (int element : arr) {
        // 将每个整数出现的次数统计到计数数组中对应下标的位置，这里需要将每个元素减去 min，才能映射到 0～range-1 范围内
        counting[element - min]++;
    }
    // 记录前面比自己小的数字的总数
    int preCounts = 0;
    for (int i = 0; i < range; i++) {
        // 当前的数字比下一个数字小，累计到 preCounts 中
        preCounts += counting[i];
        // 将 counting 计算成当前数字在结果中的起始下标位置。位置 = 前面比自己小的数字的总数。
        counting[i] = preCounts - counting[i];
    }
    int[] result = new int[arr.length];
    for (int element : arr) {
        // counting[element - min] 表示此元素在结果数组中的下标
        result[counting[element - min]] = element;
        // 更新 counting[element - min]，指向此元素的下一个下标
        counting[element - min]++;
    }
    // 将结果赋值回 arr
    for (int i = 0; i < arr.length; i++) {
        arr[i] = result[i];
    }
}
~~~

## 倒序遍历的计数排序

计数排序还有一种写法，在计算元素在最终结果数组中的下标位置这一步，不是计算初始下标位置，而是计算最后一个下标位置。最后倒序遍历 `arr` 数组，逐个将 `arr` 中的元素放到最终位置上。

两种算法的核心思想是一致的，并且都是稳定的。第一种写法理解起来简单一些，第二种写法在性能上更好一些。在计算下标位置时，不仅计算量更少，还省去了 `preCounts` 这个变量。在《算法导论》一书中，便是采用的此种写法。

实际上，这个算法最后不通过倒序遍历也能得到正确的排序结果，但这里只有通过倒序遍历的方式，才能保证计数排序的稳定性。

## 时间复杂度和空间复杂度

从计数排序的实现代码中，可以看到，每次遍历都是进行 `n` 次或者 `k` 次，所以计数排序的时间复杂度为 O(n + k)，`k` 表示数据的范围大小。

用到的空间主要是长度为 `k` 的计数数组和长度为 `n` 的结果数组，所以空间复杂度也是O(n + k)。

需要注意的是，一般我们分析时间复杂度和空间复杂度时，常数项都是忽略不计的。但计数排序的常数项可能非常大，以至于我们无法忽略。不知你是否注意到计数排序的一个非常大的隐患，比如我们想要对这个数组排序：

~~~java
int[] arr = new int[]{1, Integer.MAX_VALUE};
~~~

尽管它只包含两个元素，但数据范围是 [1, 2^{31}]，我们知道 `java` 中 `int` 占 44 个字节，一个长度为 2^31 次方的 `int` 数组大约会占 8G8G 的空间。如果使用计数排序，仅仅排序这两个元素，声明计数数组就会占用超大的内存，甚至导致 `OutOfMemory` 异常。

所以计数排序只适用于数据范围不大的场景。例如对考试成绩排序就非常适合计数排序，如果需要排序的数字中存在一位小数，可以将所有数字乘以 10，再去计算最终的下标位置。

## 计数排序与 O(nlog⁡n)O(n \log n) 级排序算法的本质区别

前文说到，希尔排序通过交换间隔较远的元素突破了排序算法时间复杂度 $O(n^2)$的下界。同样地，我们接下来就一起分析一下，计数排序凭什么能够突破 O(nlog⁡n)的下界呢？它和之前介绍的 O(nlog⁡n)级排序算法的本质区别是什么？

这个问题我们可以从决策树的角度和概率的角度来理解。

### 决策树

决策树是一棵完全二叉树，它可以反映比较排序算法中对所有元素的比较操作。

以包含三个整数的数组 [a, b, c] 为例，基于比较的排序算法的排序过程可以抽象为这样一棵 **决策树**：

![img](https://camo.githubusercontent.com/84efa4744433cd1a58f8ffbbbc9abf8fc727e636e223e6a9bab1019ae2d4c5b2/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032322f706e672f32323231393438332f313636383335353031353938302d66653965663133322d613135302d343032322d383935372d6462373530336431363066632e706e6723617665726167654875653d25323366336633663326636c69656e7449643d7537353361663765392d616534652d342663726f703d302663726f703d302663726f703d312663726f703d312669643d454f357775266e616d653d696d6167652e706e67266f726967696e4865696768743d31333537266f726967696e57696474683d32343734266f726967696e616c547970653d62696e61727926726174696f3d3126726f746174696f6e3d302673686f775469746c653d66616c73652673697a653d313636333331267374617475733d646f6e65267374796c653d6e6f6e65267461736b49643d7531356661613639372d313761392d343162642d386564622d3130393939623030353436267469746c653d)

这棵决策树上的每一个叶结点都对应了一种可能的排列，从根结点到任意一个叶结点之间的最短路径（也称为「简单路径」）的长度，表示的是完成对应排列的比较次数。所以从根结点到叶结点之间的最长简单路径的长度，就表示比较排序算法中最坏情况下的比较次数。

设决策树的高度为 `h`，叶结点的数量为 `l`，排序元素总数为 `n` 。

因为叶结点最多有 n! 个，所以我们可以得到：n!≤ l，又因为一棵高度为 `h` 的二叉树，叶结点的数量最多为2^h ，所以我们可以得到：n!≤ l ≤ 2^h

对该式两边取对数，可得：h≥log (n!)

由斯特林（`Stirling`）近似公式，可知 lg⁡(n!)=O(nlog⁡n)

所以 h≥log⁡(n!)=O(nlog⁡n)

于是我们可以得出以下定理：

> 《算法导论》定理 8.1：在最坏情况下，任何比较排序算法都需要做 O(nlog⁡n) 次比较。

由此我们还可以得到以下推论：

> 《算法导论》推论 8.2：堆排序和归并排序都是渐进最优的比较排序算法。

到这里我们就可以得出结论了，如果基于比较来进行排序，无论怎么优化都无法突破 O(nlog⁡n)的下界。计数排序和基于比较的排序算法相比，根本区别就在于：它不是基于比较的排序算法，而是利用了数字本身的属性来进行的排序。整个计数排序算法中没有出现任何一次比较。

### 概率

相信大家都玩过「猜数字」游戏：一方从 [1, 100] 中随机选取一个数字，另一方来猜。每次猜测都会得到「高了」或者「低了」的回答。怎样才能以最少的次数猜中呢？

答案很简单：二分。

二分算法能够保证每次都排除一半的数字。每次猜测不会出现惊喜（一次排除了多于一半的数字），也不会出现悲伤（一次只排除了少于一半的数字），因为答案的每一个分支都是等概率的，所以它在最差的情况下表现是最好的，猜测的一方在 log⁡n次以内必然能够猜中。

基于比较的排序算法与「猜数字」是类似的，每次比较，我们只能得到 a>b 或者 a≤b两种结果，如果我们把数组的全排列比作一块区域，那么每次比较都只能将这块区域分成两份，也就是说每次比较最多排除掉 1/2 的可能性。

再来看计数排序算法，计数排序时申请了长度为 `k` 的计数数组，在遍历每一个数字时，这个数字落在计数数组中的可能性共有 `k` 种，但通过数字本身的大小属性，我们可以「一次」把它放到正确的位置上。相当于一次排除了 (k−1)/k种可能性。

这就是计数排序算法比基于比较的排序算法更快的根本原因。

# 基数排序

想一下我们是怎么对日期进行排序的。比如对这样三个日期进行排序：2014 年 1 月 7 日，2020 年 1 月 9 日，020 年 7 月 10 日。

我们大脑中对日期排序的思维过程是：

- 先看年份，2014 比 2020 要小，所以 2014 年这个日期应该放在其他两个日期前面。
- 另外两个日期年份相等，所以我们比较一下月份，1 比 7 要小，所以 1 月这个日期应该放在 7 月这个日期前面

这种利用多关键字进行排序的思想就是基数排序，和计数排序一样，这也是一种线性时间复杂度的排序算法。其中的每个关键字都被称作一个基数。

比如我们对 999,997,866,666 这四个数字进行基数排序，过程如下：

- 先看第一位基数：6 比 8 小，8 比 9 小，所以 666 是最小的数字，866 是第二小的数字，暂时无法确定两个以 9 开头的数字的大小关系
- 再比较 9 开头的两个数字，看他们第二位基数：9 和 9 相等，暂时无法确定他们的大小关系
- 再比较 99 开头的两个数字，看他们的第三位基数：7 比 9 小，所以 997 小于 999

基数排序有两种实现方式。本例属于「最高位优先法」，简称 `MSD (Most significant digital)`，思路是从最高位开始，依次对基数进行排序。

与之对应的是「最低位优先法」，简称 `LSD (Least significant digital)`。思路是从最低位开始，依次对基数进行排序。使用 `LSD` 必须保证对基数进行排序的过程是稳定的。

通常来讲，`LSD` 比 `MSD` 更常用。以上述排序过程为例，因为使用的是 `MSD`，所以在第二步比较两个以 99 开头的数字时，其他基数开头的数字不得不放到一边。体现在计算机中，这里会产生很多临时变量。

但在采用 `LSD` 进行基数排序时，每一轮遍历都可以将所有数字一视同仁，统一处理。所以 `LSD` 的基数排序更符合计算机的操作习惯。

基数排序最早是用在卡片排序机上的，一张卡片有 80 列，类似一个 80 位的整数。机器通过在卡片不同位置上穿孔表示当前基数的大小。卡片排序机的排序过程就是采用的 `LSD` 的基数排序。

## 动图演示

简单起见，我们先只考虑对非负整数排序的情况
![img](https://camo.githubusercontent.com/51e808447c1ec79e62ee668490b2d09b43820d7202d7b1325db29e8ce4faccf7/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032322f6769662f32323231393438332f313636383335353030353230372d64313465653538652d336461392d343232612d613361632d6366313465363233613138352e67696623617665726167654875653d25323330323031303026636c69656e7449643d7537353361663765392d616534652d342663726f703d302663726f703d302663726f703d312663726f703d312669643d48324e7546266f726967696e4865696768743d363038266f726967696e57696474683d363038266f726967696e616c547970653d62696e61727926726174696f3d3126726f746174696f6e3d302673686f775469746c653d66616c7365267374617475733d646f6e65267374796c653d6e6f6e65267461736b49643d7563313761316335652d333933392d343962342d623433652d3637396234323963373064267469746c653d)

基数排序可以分为以下三个步骤：

- 找出数组中最大的数字的位数 `maxDigitLength`
- 获取数组中每个数字的基数
- 遍历 `maxDigitLength` 轮数组，每轮按照基数对其进行排序

## 找出数组中最大的数字的位数

首先找到数组中的最大值:

~~~go
func radixSort(arr []int) {
	if arr == null {
		return
	}
	max := 0
	for _, value := range arr {
		if value > max {
			max = value
		}
	}
	// ......
}
~~~

通过遍历一次数组，找到了数组中的最大值 `max`，然后我们计算这个最大值的位数：

~~~go
maxDigitLength := 0
for max != 0 {
	maxDigitLenth++
	max /= 10
}
~~~

将 `maxDigitLength` 初始化为 0，然后不断地除以 10，每除一次，`maxDigitLength` 就加一，直到 `max` 为 0。

读者可能会有疑惑，如果 `max` 初始值就是 0 呢？严格来讲，0 在数学上属于 1 位数。

但实际上，基数排序时我们无需考虑 `max` 为 0 的场景，因为 `max` 为 0只有一种可能，那就是数组中所有的数字都为0，此时数组已经有序，我们无需再进行后续的排序过程。

## 获取基数

获取基数有两种做法：  
第一种：

~~~go
mod := 10
dev := 1
for i := 0; i < maxDigitLenth; i++ {
	for _, value := range arr {
		radix := value % mod / dev
		// 对基数进行排序
	}
	mod *= 10
	dev *= 10
}
~~~
第二种:

~~~go
dev := 1
for i := 0; i < maxDigitLength; i++ {
	for _, value := range arr {
		radix := balue / div % 10
		// 对基数进行排序
	}
	dev *= 10
}
~~~

两者的区别是先做除法运算还是先做模运算，推荐使用第二种写法，因为它可以节省一个变量。

## 对基数进行排序

对基数进行排序非常适合使用我们在上一节中学习的计数排序算法，因为每一个基数都在 [0, 9] 之间，并且计数排序是一种稳定的算法。

`LSD` 方式的基数排序代码如下：
~~~go
func radixSort(arr []int) {
	if arr == null {
		return
	}
	max := 0
	for _, value := range arr {
		if value > max {
			max = value
		}
	}
	// 计算最大数字的长度
	maxDigitLength := 0
	for max != 0 {
		maxDigitLenth++
		max /= 10
	}
	// 使用计数排序发对基数进行排序
	counting := make([]int, 10)
	result := make([]int, len(arr))
	dev := 1
	for i := 0; i < maxDigitLength; i++ {
		for _, value := range arr {
			radix := balue / div % 10
			counting[radix]++
		}
		for j := 0; j < len(counting); j++ {
			counting[j] += counting[j - 1]
		}
		// 使用倒序遍历的方式完成计数排列
		for j := len(arr) - 1; j >= 0; j-- {
			radix := arr[j] / dev % 10
			result[--counting[radix]] = arr[j]
		}
		// 计数排序完成后，将结果拷贝会 arr
		for i := 0; i < len(arr); i++ {
			arr[i] = result[i]
			// 将计数数组重置为0
			result[i] = 0
		}
		dev *= 10
	}
}
~~~
计数排序的思想上一节已经介绍过，这里不再赘述。当每一轮对基数完成排序后，我们将 `result` 数组的值拷贝回 `arr` 数组，并且将 `counting` 数组中的元素都置为 0，以便在下一轮中复用。

## 对包含负数的数组进行基数排序

如果数组中包含负数，如何进行基数排序呢？  
我们很容易想到一种思路：将数组中的每个元素都加上一个合适的正整数，使其全部变成非负整数，等到排序完成后，再减去之前加的这个数就可以了。

但这种方案有一个缺点：加法运算可能导致数字越界，所以必须单独处理数字越界的情况。

事实上，有一种更好的方案解决负数的基数排序。那就是在对基数进行计数排序时，申请长度为 19 的计数数组，用来存储 [-9, 9] 这个区间内的所有整数。在把每一位基数计算出来后，加上 9，就能对应上 `counting` 数组的下标了。也就是说，`counting` 数组的下标 [0, 18] 对应基数 [-9, 9]。

代码中主要做了两处修改：

- 当数组中存在负数时，我们就不能简单的计算数组的最大值了，而是要计算数组中绝对值最大的数，也就是数组中最长的数
- 在获取基数的步骤，将计算出的基数加上 9，使其与 `counting` 数组下标一一对应

## 时间复杂度 & 空间复杂度

无论 `LSD` 还是 `MSD`，基数排序时都需要经历 `maxDigitLength` 轮遍历，每轮遍历的时间复杂度为 O(n + k) ，其中 `k` 表示每个基数可能的取值范围大小。如果是对非负整数排序，则 `k = 10`，如果是对包含负数的数组排序，则 `k = 19`。

所以基数排序的时间复杂度为 O(d(n + k))(`d` 表示最长数字的位数，`k` 表示每个基数可能的取值范围大小)。

使用的空间和计数排序是一样的，空间复杂度为 O(n + k)（`k` 表示每个基数可能的取值范围大小）。


# 桶排序

桶排序的思想是：

- 将区间划分为 `n` 个相同大小的子区间，每个子区间称为一个桶
- 遍历数组，将每个数字装入桶中
- 对每个桶内的数字单独排序，这里需要采用其他排序算法，如插入、归并、快排等
- 最后按照顺序将所有桶内的数字合并起来

桶排序在实际工作中的应用较少，不仅因为它需要借助于其他排序算法，还因为桶排序算法基于一个假设：所有输入数据都服从均匀分布，也就是说输入数据应该尽可能地均匀分布在每个桶中。只有这个假设成立时，桶排序运行效率才比较高。

在最差的情况下，所有数据都会被装入同一个桶中，此时桶排序算法只会徒增一轮遍历。

使用桶排序算法时，我们需要考虑两个因素：

- 设置多少个桶比较合适
- 桶采用哪种数据结构

这两个因素会直接影响到桶排序的内存和效率。

- **桶的数量**：桶的数量过少，会导致单个桶内的数字过多，桶排序的时间复杂度就会在很大程度上受桶内排序算法的影响。桶的数量过多，占用的内存就会较大，并且会出现较多的空桶，影响遍历桶的效率。具体设置多少个桶需要根据实际情况决定。
- **桶的数据结构**：如果将桶的数据结构设置为数组，那么每个桶的长度必须设置为待排序数组的长度，因为我们需要做好最坏的打算，即所有的数字都被装入了同一个桶中，所以这种方案的空间复杂度会很高。  

那么是不是将桶的数据结构设置为链表就更好呢？使用链表有一个好处，即所有桶的总长度刚好等于待排序数组的长度，不会造成内存浪费。但使用链表也会有一些问题，我们待会一一分析。

接下来我们就分别学习一下这两种数据结构实现的桶排序算法。

## 以数组作为桶

首先，找到最大值和最小值：
~~~go
func bucketSort(arr []int) {
	// 判空及防止数组越界
	if arr == null || len(arr) <= 1 {
		return
	}
	// 找到最大值，最小值
	max := arr[0]
	min := arr[0]
	for i := 1; i < len(arr); i++ {
		if arr[i] > max {
			max = arr[i]
		}else if arr[i] < min {
			min = arr[i]
		}
	}
	//确定取值范围
	rang := max - min
	//......
}
~~~

这里需要遍历一轮数组。  
下一步，开始装桶：

~~~go
// 设置桶的数量，这里我们设置为 100 个，可以根据实际情况修改。
bucketAmount = 100
// 桶和桶之间的间距
var gap double = rang * 1.0 / (bucketAmount - 1)
/* 用二维数组来装桶，第一个维度是桶的编号，
第二个维度是桶中的数字。
每个桶的长度必须设置为 arr.length，
因为我们要做好最坏的打算：所有的数字都被装入了一个桶中。*/
buckets := make([][]int, bucketAmount)
for i := 0; i < bucketAmount; i++ {
	buckets[i] = make([]int, len(arr))
}
// 单独采用一个数组来记录每个桶当前的长度，也就是当前桶内共有多少个数字。
bucketLength := make([]int, bucketAmount)
// 装桶
for _, value := range arr {
	// 找到 value 属于哪个桶
	index := int((value - min)/gap)
	// 装桶后，更新 bucketLength[index]
	buckets[index][bucketLength[index]++] = value
}
~~~

我们将桶的数量设置为 100 个，这个值可以根据输入数据的实际情况修改。所有的桶是一个二维数组，第一个维度代表桶的编号，第二个维度代表桶内的数字，每个桶中都有一组数字。

由于每个桶的长度都等于待排序数组的长度，所以我们还需要一个单独的数组来记录当前桶内的有效数字数量。

装桶时需要做一些简单的运算：先通过第一步找到的取值范围计算出每个桶之间的间距，再通过当前数字与最小值的距离除以间距计算出桶的编号，最后根据编号把当前数字放入对应的桶中。

下一步是对每个桶内的数字进行单独排序，这一步需要借助其他排序算法：

~~~go
// 对每个桶内的数字进行单独排序
index := 0
for i := 0; i < bucketAmount; i++ {
	if bucketLength == 0 {
		continue
	}
	// 取出桶内的数组
	arrInBucket := 
}