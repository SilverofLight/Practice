# 冒泡排序

冒泡排序是入门级排序，有三种写法

- 一边比较一边向后两两交换，将最大值 / 最小值冒泡到最后一位；
- 经过优化的写法：使用一个变量记录当前轮次的比较是否发生过交换，如果没有发生交换表示已经有序，不再继续排序；
- 进一步优化的写法：除了使用变量记录当前轮次是否发生交换外，再使用一个变量记录上次发生交换的位置，下一轮排序时到达上次交换的位置就停止比较。

## 第一种写法

```go
func bubbleSort(arr []int) {
	for i := 0; i < len(arr)-1; i++ {
		for j := 0; j < len(arr)-i-1; i++ {
			if arr[j] > arr[j+1] {
				arr[j], arr[j+1] = arr[j+1], arr[j]
			}
		}
	}
}
```

总共比较次数是 (n-1)+(n-2)+(n-3)+…+1

## 第二种写法

```go
func bubbleSort(arr []int) {
	swapped := true
	for i := 0; i < len(arr)-1; i++ {
		if !swapped {
			break
		}
		swapped = false
		for j := 0; j < len(arr)-i-1; i++ {
			if arr[j] > arr[j+1] {
				arr[j], arr[j+1] = arr[j+1], arr[j]
				swapped = true
			}
		}
	}
}
```

最外层的 for 循环每经过一轮，剩余数字中的最大值仍然是被移动到当前轮次的最后一位。这种写法相对于第一种写法的优点是：如果一轮比较中没有发生过交换，则立即停止排序，因为此时剩余数字一定已经有序了。

## 第三种写法

```go
func bubbleSort(arr []int) {
	//是否交换过
	swapped := true
	//最后交换的位置
	lastUnsorted := len(arr)-1
	//循环中暂存交换的位置
	swappedIndex := -1
	for swapped {
		swapped = false
		for i := 0; i < lastUnsorted; i++ {
			if arr[i] > arr[i+1] {
				arr[i], arr[i+1] = arr[i+1], arr[i]
				//发生了交换
				swapped = true
				//更新交换的位置
				swappedIndex = i
			}
		}
		lastUnsorted = swappedIndex
	}
}
```

## 附：交换的技巧

一般交换：

```go
int temp = arr[i];
arr[i] = arr[j];
arr[j] = temp;
```

不使用第三个中间变量的交换：

```go
arr[j + 1] = arr[j + 1] + arr[j];
arr[j] = arr[j + 1] - arr[j];
arr[j + 1] = arr[j + 1] - arr[j];
```

也可以先减后加：

```go
arr[j + 1] = arr[j] - arr[j + 1];
arr[j] = arr[j] - arr[j + 1];
arr[j + 1] = arr[j + 1] + arr[j];
```

但这两种方式都可能导致数字越界。

更好的方案是通过位运算完成数字交换：

```go
arr[i] = arr[i] ^ arr[j];
arr[j] = arr[j] ^ arr[i];
arr[i] = arr[i] ^ arr[j];
```

# 选择排序

## 写法

选择排序的思想是：双重循环遍历数组，每经过一轮比较，找到最小元素的下标，将其交换至首位。

```go
func selectionSort (arr []int) {
	var minIndex int
	for i := 0; i < len(arr)-1; i++ {
		minIndex = i
		for j := i+1; j < len(arr); j++ {
			if arr[minIndex] > arr[j] {
				minIndex = j
			}
		}
		//将最小的元素交换至首位
		arr[i], arr[minIndex] = arr[minIndex], arr[i]
	}
}
```

正是由于它比较容易理解，许多初学者在排序时非常喜欢使用选择排序法。

现在让我们思考一下，冒泡排序和选择排序有什么异同？

相同点：

- 都是两层循环，时间复杂度都为O(n^2);
- 都只使用有限个变量，空间复杂度 O(1)。

不同点：

- 冒泡排序在比较过程中就不断交换；而选择排序增加了一个变量保存最小值 / 最大值的下标，遍历完成后才交换，减少了交换次数。

事实上，冒泡排序和选择排序还有一个非常重要的不同点，那就是：

- 冒泡排序法是稳定的，选择排序法是**不稳定**的。

## 排序算法的稳定性

> 假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i] = r[j]，且 r[i] 在 r[j] 之前，而在排序后的序列中，r[i] 仍在 r[j] 之前，则称这种排序算法是稳定的；否则称为不稳定的。

冒泡排序中，只有左边的数字大于右边的数字时才会发生交换，相等的数字之间不会发生交换，所以它是稳定的。

而选择排序中，最小值和首位交换的过程可能会破坏稳定性。比如数列：[2, 2, 1]，在选择排序中第一次进行交换时，原数列中的两个 2 的相对顺序就被改变了，因此，我们说选择排序是不稳定的。

**那么排序算法的稳定性有什么意义呢？**

**其实它只在一种情况下有意义：当要排序的内容是一个对象的多个属性，且其原本的顺序存在意义时，如果我们需要在二次排序后保持原有排序的意义，就需要使用到稳定性的算法。**

举个例子，如果我们要对一组商品排序，商品存在两个属性：价格和销量。当我们按照价格从高到低排序后，要再按照销量对其排序，这时，如果要保证销量相同的商品仍保持价格从高到低的顺序，就必须使用稳定性算法。

当然，算法的稳定性与具体的实现有关。在修改比较的条件后，稳定性排序算法可能会变成不稳定的。如冒泡算法中，如果将「左边的数大于右边的数，则交换」这个条件修改为「左边的数大于或等于右边的数，则交换」，冒泡算法就变得不稳定了。

同样地，不稳定排序算法也可以经过修改，达到稳定的效果。思考一下，选择排序算法如何实现稳定排序呢？

实现的方式有很多种，这里给出一种最简单的思路：新开一个数组，将每轮找出的最小值依次添加到新数组中，选择排序算法就变成稳定的了。 但如果将寻找最小值的比较条件由`arr[minIndex] > arr[j]`修改为`arr[minIndex] >= arr[j]`，即使新开一个数组，选择排序算法依旧是不稳定的。所以分析算法的稳定性时，需要结合具体的实现逻辑才能得出结论，我们通常所说的算法稳定性是基于一般实现而言的。

## 二元选择排序

选择排序算法也是可以优化的，既然每轮遍历时找出了最小值，何不把最大值也顺便找出来呢？这就是二元选择排序的思想。

使用二元选择排序，每轮选择时记录最小值和最大值，可以把数组需要遍历的范围缩小一倍。

```go
func selectionSort2(arr []int) {
	var minIndex, maxIndex int
	//i只需要遍历一半
	for i := 0; i < len(arr)/2; i++ {
		minIndex = maxIndex = i
		for j := i + 1; j < len(arr)-1; j++ {
			if arr[minIndex] > arr[j] {
				minIndex = j
			}
			if arr[maxIndex < arr[j] {
				maxIndex = j
			}
		}
		//如果 minIndex和maxIndex相等，那么它们必定都等于i，且后面的数字都与arr[i]相等，
		//此时已经排序完成
		if minIndex == maxIndex {
			break
		}
		
		//交换最小值
		arr[i], arr[minIndex] = arr[minIndex], arr[i]
		
		//如果最大值的下标刚好是i，由于a[i]和arr[minIndex]已经交换了，所以需要更新
		if maxIndex == i {
			maxIndex = minIndex
		}
		
		//交换最大值
		arr[len(arr)-1], arr[maxIndex] = arr[maxIndex], arr[len(arr)-1]
	}
}
```

二元选择排序中有一句很重要的代码，它位于`交换最小值`和`交换最大值`的代码中间：

```go
if maxIndex == i {
	maxIndex = minIndex
}
```

这行代码的作用处理了一种特殊情况：如果最大值的下标等于 i，也就是说 arr[i] 就是最大值，由于 arr[i] 是当前遍历轮次的首位，它已经和 arr[minIndex] 交换了，所以最大值的下标需要跟踪到 arr[i] 最新的下标 minIndex。

## 二元选择排序的效率

在二元选择排序算法中，数组需要遍历的范围缩小了一倍。那么这样可以使选择排序的效率提升一倍吗？

从代码可以看出，虽然二元选择排序最外层的遍历范围缩小了，但 for 循环内做的事情翻了一倍。也就是说二元选择排序无法将选择排序的效率提升一倍。但实测会发现二元选择排序的速度确实比选择排序的速度快一点点，它的速度提升主要是因为两点：

- 在选择排序的外层 for 循环中，`i` 需要加到 `arr.length - 1` ，二元选择排序中 `i` 只需要加到 `arr.length / 2`
- 在选择排序的内层 for 循环中，`j` 需要加到 `arr.length` ，二元选择排序中 `j` 只需要加到 `arr.length - i`

和选择排序一样，二元选择排序也是不稳定的。

# 插入排序

插入排序的思想非常简单，生活中有一个很常见的场景：在打扑克牌时，我们一边抓牌一边给扑克牌排序，每次摸一张牌，就将它插入手上已有的牌中合适的位置，逐渐完成整个排序。

插入排序有两种写法：

- 交换法：在新数字插入过程中，不断与前面的数字交换，直到找到自己合适的位置。
- 移动法：在新数字插入过程中，与前面的数字不断比较，前面的数字不断向后挪出位置，当新数字找到自己的位置后，插入一次即可。

## 交换法插入排序

```go
func insertSort arr []int {
	//从第二个数开始，往前插入数字
	for i := 1; i < len(arr); i ++ {
		//记录当前数字坐标
		j := i;
		//当前数字比前一个数字小，则交换
		for j >= 1 && arr[j] < arr[j - 1] {
			arr[j], arr[j-1] = arr[j-1], arr[j]
			j--
		}
	}
}
```

当数字少于两个时，不存在排序问题，当然也不需要插入，所以我们直接从第二个数字开始往前插入。

整个过程就像是已经有一些数字坐成了一排，这时一个新的数字要加入，这个新加入的数字原本坐在这一排数字的最后一位，然后它不断地与前面的数字比较，如果前面的数字比它大，它就和前面的数字交换位置。

## 移动法插入排序

实际上，新插入的这个数字并不一定适合与它交换的数字所在的位置。也就是说，它刚换到新的位置上不久，下一次比较后，如果又需要交换，它马上又会被换到前一个数字的位置。

由此，我们可以想到一种优化方案：让新插入的数字先进行比较，前面比它大的数字不断向后移动，直到找到适合这个新数字的位置后，新数字只做一次插入操作即可。

这种方案我们需要把新插入的数字暂存起来，代码如下：

```go
func inserSort(arr []int) {
	//从第二个数开始，往前插入数字
	for i := 1; i < len(arr); i++ {
		number := arr[i]
		j := i - 1
		//寻找插入的位置，同时把比num大的数字往后挪
		for j >= 0 && number < arr[j] {
			arr[j + 1] = arr[j]
			j--
		}
		arr[j + 1] = number
	}
}
```

插入排序的过程不会破坏原有数组中相同关键字的相对次序，所以插入排序是一种稳定的排序算法。